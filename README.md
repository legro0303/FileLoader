## Используемые технологии

1. БД - PostgreSQL
2. IDE - Visual studio 2022
3. ORM - Entity Framework
4. Шаблон проекта - Веб-приложение ASP.NET Core(модель-представление-контроллер)
5. Библиотека для определения MimeType - MimeTypeOfficialMap

## Задание
Необходимо реализовать web-сервис загрузки и хранения файлов.

Платформа: .NetCore
Язык: C#

Функционал:
1. Возможность загрузить и сохранить в БД файл.
2. Возможность одновременной загрузки нескольких файлов и отображением статуса успешности загрузки каждого файла в режиме онлайн.
3. Возможность просмотра списка загруженных файлов и скачивание их по отдельности.
4. Возможность генерации одноразовой ссылки для скачивания файла.

Требования:
Выбрать СУБД и способ хранения самостоятельно.

Далее будет описана реализация каждого пункта.

## Пункт 0.Ссылка на видео-демонстрацию (Идет 2 минуты)
https://drive.google.com/file/d/1Dqb4FqEEwtMOz8knLvzPsCSEGjFZuzEF/view?usp=sharing

## Пункт 1. Возможность загрузить и сохранить в БД файл.
Загрузив файл на странице "https://localhost:port/Upload" будет вызван Action UploadFiles из контроллера UploadController.
Данный метод(UploadFiles) определяет текущий хост, после чего вызывает метод addToDb(), класса LoadService.
Но прежде чем поместить в БД наши файлы, их нужно обогатить данными, используя метод GetListOfFilesEntities().
GetListOfFilesEntities() получает список загруженных файлов и строку хоста, в цикле создает модель класса FileModel и заполняет каждое поле объекта(за исключением Id, которое будет заполнено автоматически при инсерте в таблицу).
file.OriginalName получаем из названия пришедшего в метод файла,
file.StorageName генерируем самостоятельно (Данное поле необходмо для того, чтобы исключить перезапись файлов с одинаковым названием на сервере, т.к. все файлы будут храниться в одной папке).
file.Path получаем создав новый файл на сервере (Директория C:\\storage\\) и считав байты из полученного в UploadFiles объекта.
file.FullLink и file.GeneratedPartOfLink получаем из метода createLink, который создает одноразовую ссылку вида "https://localhost:port/Controller/Action/RandomString", где RandomString - модуль от hashCode от случайно сгенерированного GUID.
После того, как список обогащенных объектов (объектов класса FilesModel) успешно создан, будет вызван метод addToDb(), который использует метод AddAllFiles() из класса FileRepository.
Класс FileRepository реализует интерфейс IFileRepository. FileRepository работает с объектом класса Context, который наследует класс DbContext фреймворка EntityFramework.
Context позволяет нам реализовать CRUD операции без написания SQL-запросов, используя уже готовые методы класса. 
Для добавления всех полученных файлов используется метод AddRange(), сохранить изменения не только в контексте нашего приложения, но и в самой БД позволяет метод SaveAllChanges().
## Подпункт 1.1. Реализация соединения с БД.
Для соединения с БД используется фреймворк EntityFramework. В методе ConfigureServices класса Startup в список сервисов помещается наш контекст, который соединяется с БД используя параметры конфигурации из строки с названием "DefaultConnection".
DefaultConnection находится в файле appsettings.json и имеет вид "Server=server;Port=####;Database=DBName;UserId=UserName;Password=Pass;"
Поместив контекст в список сервисов мы можем использовать объект этого класса не инициализируя его напрямую. P.S. Если я правильно понял, работает также, как аннотация @Autowired в Java.
## Подпункт 1.2. Создание таблицы.
Создание таблицы основано на паттерне Code First. Таким образом таблица создается сама, благодаря методу Database.EnsureCreated(). Создание происходит на основе полей модели FileModel.
Различные аттрибуты позволяют создать таблицу такой, какой она должна быть для задачи.Так, "Required" означает, что поле обязательно должно быть заполнено при вставке объекта в БД. "Key", указывает на то, какое поле будет Primary Key,
а DatabaseGenerated(DatabaseGeneratedOption.Identity) позволяет автоинкрементировать id при его вставке.

## Пункт 2.  Возможность одновременной загрузки нескольких файлов и отображением статуса успешности загрузки.
При запуске приложения мы попадем на главную страницу с двумя кликабельными ссылками - "Upload the file" и "View list of uploaded files".
Для загрузки и сохранения файла в БД необходимо перейти по ссылке "Upload the file". При клике по ссылке произойдёт обращение к контроллеру HomeController, будет вызван Action с именем Upload.
Action Upload перенаправит нас на Action Index в контроллере Upload, который вернёт страницу (представление) Index.cshtml из директории Views/Upload.
На данной странице будут представлены две кнопки - "Выбрать файлы" и "Upload" а также пустая таблица с столбцами "Files" и "Success".
Мы можем загрузить как один файл, так и несколько. Это возможно благодаря аттрибуту "multiple" в input-элементе "file" представления "/Upload/Index.cshtml".
После выбора файлов появиться progressBar, обозначающий старт загрузки файлов.
Файлы загружаются на сервер благодаря Ajax-запросу, используя Http метод POST. Запрос направляется прямиком в метод UploadFiles(), контроллера Upload.
Там, как уже написано выше (Пункт 1), полученные файлы будут сохранены на сервере и в БД, но чтобы отобразить успешность/не успешность загрузки каждого файла, нам необходимо вернуть статус загрузки назад клиенту (фронту).
Для этого в цикле foreach вычленяется имя файла и выставляется флаг успешности/не успешности загрузки(зависит от того, оказался ли полученный файл равным null).
Два этих поля помещаются в объекты класса UploadedFileDTO, предназначенного для обмена информацией клиента и сервера.
После чего результат мапится в столбцы таблицы, в scipt section представления.

## Пункт 3. Возможность просмотра списка загруженных файлов и скачивание их по отдельности
Для просмотра списка загруженных файлов требуется нажать на ссылку "View the list of uploaded file".
При переходе будет вызван Action ListOfFiles() контроллера HomeController, который перенаправит нас на метод Index() контроллера ListOfFiles.
Метод Index() вызовет методе GetAllFiles() класса FileRepository, который вернёт список всех объектов, хранящихся в БД.
Этот список будет возвращен вместе с представлением. Внутри самого представления (/ListOfFiles/Index.cshtml) список будет распаршен в столбцы таблицы. 
Чтобы скачать файл требуется нажать по ссылке "Download". При нажатии будет вызван контроллер Download(), а именно метод Index(), который принимает на вход случайно сгенерированную одноразовую часть ссылки.
По данной части будет получен путь к файлу на сервере, из которого будут считаны все байты в новый, возвращаемый клиенту файл. Имя файла будет тем, с которым оно было загружено, несмотря на то, что на сервере оно хранится со случайно сгенерированным именем.
Здесь то и пригодиться библиотека MimeTypeOfficialMap, т.к. чтобы вернуть файл нам обязательно требуется указать его content-type.
При попытке повторно нажать Download по тому же элементу будет получено сообщение "Ссылка больше не является действительной", т.к. все ссылки в таблице одноразовые.

## Пункт 4. Возможность генерации одноразовой ссылки для скачивания файла.
Все ссылки для скачивания в таблице одноразовые. Действительно ли ссылка одноразовая можно проверить кликнув по ссылке "Download" два раза подряд, не кликая на ссылку "Generate".
Будет получено сообщение "Ссылка больше не является действительной". После нажатия по ссылке "Download" или по ссылке "Generate" в обоих случаях будет вызван метод ChangeLink() класса LoadService.
Данный метод ищет файл с указанной ссылкой в БД, получает host из ссылки, которая пришла в качестве аргумента в метод, и вызывает метод createLink(), который генерирует новую случайную ссылку, после чего заменяет старую ссылку - новой и сохраняет её
в БД посредством метода UpdateLink().
Разница между нажатием по "Download" и "Generate" в том, что при нажатии по "Generate" после смены ссылки будет вызван Action Index() контроллера ListOfFiles, 
который вернёт нам заново отрисованное представление с уже обновлёнными ссылками из только что изменившейся таблицы в БД.